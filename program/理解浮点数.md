# 理解浮点数
- [理解浮点数](#理解浮点数)
  - [IEEE754 标准](#ieee754-标准)
  - [浮点数的 IEEE754 表示](#浮点数的-ieee754-表示)
  - [小数的二进制(binary)和十进制(decimal)转换](#小数的二进制binary和十进制decimal转换)
  - [其它问题](#其它问题)
  - [来源](#来源)

## IEEE754 标准
IEEE二进制浮点数算数标准是20世界80年代依赖最广泛使用的浮点数运算标准，为许多CPU与浮点运算器所采用的。这个标准定义了表示浮点数的格式（包括负零）与反常值（denormal number)，一些特殊值（无穷infinity与非数值NaN)，有规定基数为2的状况等等。

浮点数构成是指用符号、尾数、基数和指数这四部分来表示的小数。

![浮点数构成](https://github.com/frank-dc/drawpics/blob/main/the_structure_of_floating_point.png?raw=true)

```text
S: 表示符号位，占 1 比特，取值 0(表示正数) 和 1(表示负数)。
E: 表示指数部分，单精度浮点数占 8 比特，双进度浮点数占 11 比特。
M: 表示尾数部分，单精度浮点数占 23 比特，双进度浮点数占 52 比特。
```

比如:

十进制数 2.75 转成二进制数 10.11，根据 IEEE754，可以表示成 (-1)<sup>0</sup> x 1.011 x 2<sup>1</sup>

十进制数 -0.75 转成二进制数 -0.11， 根据 IEEE754，可以表示成 (-1)<sup>1</sup> x 1.1 x 2<sup>-1</sup>


## 浮点数的 IEEE754 表示
![浮点数的 IEEE754 表示](https://github.com/frank-dc/drawpics/blob/main/ieee754_express_of_floating_point.png?raw=true)

一般，IEEE754 浮点数有两种类型：单精度浮点数（使用 4 字节表示）和双精度浮点数（使用 8 字节表示），其他的不常用。

> 尾数部分

IEEE754 规定，在二进制数中，通过移位，将小数点前面的值固定为 1，因此 1 <= M < 2，M 可以写成 1.xxxxxxxx 的形式，第一位是 1，可以省略不存，只保存 xxxxxxxx 部分，等于尾数部分可以保存 24 位有效数字。

比如十进制数 0.15625，转为二进制是 0.00101。为了让第一位为 1，右移 3 位， 尾数部分变成 1.01，因为右移了 3 位，所以指数部分 -3。

> 指数部分

`指数有正负之分，为了避免使用符号位，IEEE754 规定，2<sup>e-1</sup> 的值是中间数，也就是 0，其中 e 表示指数部分的位数，小于这个值表示负数，大于这个值表示正数。因此，对于单精度浮点数，2<sup>8-1</sup> - 1 = 127 是 0；双精度浮点数，2<sup>11-1</sup> - 1 = 1023 是 0。`

指数部分的真实值 = E + 127/1023。

比如十进制数 0.15625，因为右移了 3 位，所以指数是 -3。根据 IEEE754 的规定，单精度浮点数情况下，-3 的实际值是 127 - 3 = 124，而十进制的 124 转为二进制就是 0111 1100。

指数的两种特殊情况
* E 的二进制表示全是 0，浮点数的指数 E 的十进制等于 -126（或者-1022），有效数字 M 不再加上第一位的 1，而是还原为 0.xxxxxx 的小数，这样做是为了表示 ±0，以及接近于 0 的很小的数字。[^1]
* E 的二进制表示全是 1，如果有效数字 M 的二进制表示全是 0，表示正负无穷大(± infinity)；如果有效数字 M 的二进制表示不全为 0， 表示这个数不是一个数（NaN）。
* E 的二进制表示不全是 0 或不全是 1， 上面讨论的就是`规范化浮点数`。
* E 的二进制表示全是 1，如果有效数字 M 的二进制表示全是 0，表示正负无穷大(± infinity)；如果有效数字 M 的二进制表示不全为 0， 表示这个数不是一个数（NaN）。

[^1]: 当指数位全是 0，尾数部分不全是 0，尾数部分没有省略的前导 1，同时指数部分的偏移值比规范形式的偏移值小 1，即单精度是 -126，双精度是 -1022。这种形式的浮点数叫`非规范化浮点数`。

> 小结

结合尾数部分和指数部分，IEEE754 单精度浮点数，十进制 0.15625 对应的二进制内存表示是：`0` `01111100` `01000000000000000000000`

上面的 (2.75)<sub>10</sub> 对应的二进制内存表示是：`0` `10000000` `01100000000000000000000`

上面的 (-0.75)<sub>10</sub> 对应的二进制内存表示是：`1` `01111110` `10000000000000000000000`


## 小数的二进制(binary)和十进制(decimal)转换
* 二进制转十进制

和整数二进制转十进制一样，采用各位数值和位权相乘，比如

(0.101)<sub>2</sub> = 1x2<sup>-1</sup> + 0x2<sup>-2</sup> + 1x2<sup>-3</sup> = (0.625)<sub>10</sub>

记住小数点后第一位是从 -1 开始。

* 十进制转二进制

整数十进制转二进制是采用`除 2 取余，逆序排列`。

小数十进制转二进制是采用`乘 2 取整，顺序排列`。
```text
0.625 * 2 = 1.25    取整数部分 1
0.25 * 2 = 0.5      取整数部分 0
0.5 * 2 = 1         取整数部分 1
```
所以，(0.625)<sub>10</sub> = (0.101)<sub>2</sub> 


## 其它问题
```text
0.1 + 0.2 = 0.30000000000000004

0.2 + 0.4 = 0.6000000000000001
```
出现这种情况的根本原因是，有些十进制小数无法转换成二进制数，只能增加位数来尽可能近似地表示。

(0.1)<sub>10</sub> = (0.0001100110011001100110011001100...)<sub>2</sub>  后面无限循环`1100`

所以 0.1 采用单精度表示 1x2<sup>-4</sup> + 1x2<sup>-5</sup> + 1x2<sup>-8</sup> + 1x2<sup>-9</sup> + 1x2<sup>-12</sup> + 1x2<sup>-13</sup> + 1x2<sup>-16</sup> + 1x2<sup>-17</sup> + 1x2<sup>-20</sup> + 1x2<sup>-21</sup> + 1x2<sup>-24</sup> + 1x2<sup>-25</sup> + ...

即 
$$\frac{1}{2^{4}} + \frac{1}{2^{5}} + \frac{1}{2^{8}} + \frac{1}{2^{9}} + \frac{1}{2^{12}} + \frac{1}{2^{13}} + \frac{1}{2^{16}} + \frac{1}{2^{17}} + \frac{1}{2^{20}} + \frac{1}{2^{21}} + \frac{1}{2^{24}} + \frac{1}{2^{25}} + ...$$

近似 0.100000001490116119384765625

类似 0.2 采用单精度表示近似 0.20000000298023223876953125

[在线浮点数表示网址](https://baseconvert.com/ieee-754-floating-point)

## 来源
* [https://polarisxu.studygolang.com/posts/basic/diagram-float-point/](https://polarisxu.studygolang.com/posts/basic/diagram-float-point/)
* [https://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html](https://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html)
* 《深入理解计算机系统》第一部分 程序执行和结构 第二章 信息的表示和处理 2.4 浮点
