# CPU负载高或利用率高排查
- [CPU负载高或利用率高排查](#cpu负载高或利用率高排查)
  - [一、CPU负载高（Load Average）排查步骤](#一cpu负载高load-average排查步骤)
    - [✅ 背景定义](#-背景定义)
    - [🧭 排查思路总览：](#-排查思路总览)
    - [🧪 详细排查步骤](#-详细排查步骤)
      - [1. 查看负载与CPU核数的关系](#1-查看负载与cpu核数的关系)
      - [2. 查看运行队列](#2-查看运行队列)
      - [3. 检查是否存在过多上下文切换](#3-检查是否存在过多上下文切换)
      - [4. 查看中断情况](#4-查看中断情况)
      - [5. 查找不可中断状态（D状态）进程](#5-查找不可中断状态d状态进程)
  - [二、CPU利用率高（CPU Usage）排查步骤](#二cpu利用率高cpu-usage排查步骤)
    - [✅ 背景定义](#-背景定义-1)
    - [🧭 排查思路总览：](#-排查思路总览-1)
    - [🧪 详细排查步骤](#-详细排查步骤-1)
      - [1. 查看 CPU 各状态占比](#1-查看-cpu-各状态占比)
      - [2. 定位高 CPU 进程](#2-定位高-cpu-进程)
      - [3. 分析线程级别CPU](#3-分析线程级别cpu)
      - [4. 分析GC、死循环](#4-分析gc死循环)
  - [🔍 总结对比表](#-总结对比表)
  - [常见语言的调试工具：](#常见语言的调试工具)

## 一、CPU负载高（Load Average）排查步骤

### ✅ 背景定义

- **Load Average** 表示单位时间内等待CPU的平均进程数，**不仅包含正在运行的进程，还包括等待CPU的进程**。
- 重点关注：`load average` 是否**远高于 CPU 核数总量**。

------

### 🧭 排查思路总览：

| 排查点                   | 工具                             | 目的                            |
| ------------------------ | -------------------------------- | ------------------------------- |
| 当前负载与核数比         | `uptime`, `top`, `w`             | 初步判断是否异常                |
| 运行队列查看             | `vmstat`, `sar`, `top`           | 确认有多少进程在抢 CPU          |
| 中断与上下文切换         | `vmstat`, `pidstat -w`           | 判断是否因频繁切换导致 CPU 抢占 |
| 系统调用、软中断、硬中断 | `mpstat -P ALL`, `perf`, `dstat` | 查明内核态是否频繁被打断        |
| 僵尸/阻塞进程            | `ps -eo state,pid,ppid,cmd       | grep D`                         |



------

### 🧪 详细排查步骤

#### 1. 查看负载与CPU核数的关系

```
uptime
```

- 结果示例：`load average: 5.23, 4.88, 4.45`（1/5/15分钟）
- 如果为单核系统，load > 1 就可能有瓶颈；8核系统 load > 8 同理。

#### 2. 查看运行队列

```
vmstat 1 5
```

重点字段：

- `r`: 正在运行或等待运行的进程数量
- `b`: 等待IO的进程数量

```
top -1  # 看CPU核数与负载是否匹配
```

#### 3. 检查是否存在过多上下文切换

```
pidstat -w 1
```

关注：

- `cswch/s`：自愿上下文切换（进程主动放弃CPU）
- `nvcswch/s`：非自愿切换（调度器强制切换）

#### 4. 查看中断情况

```
mpstat -P ALL 1
```

关注字段：

- `%irq`：硬中断
- `%soft`：软中断
- `%steal`：被虚拟机抢占CPU的时间（尤其在云服务器中）

#### 5. 查找不可中断状态（D状态）进程

```
ps -eo pid,ppid,state,cmd | grep "^.* D "
```

若有大量 D 状态进程，可能为磁盘 IO 或网络 IO 瓶颈。

------

## 二、CPU利用率高（CPU Usage）排查步骤

### ✅ 背景定义

- CPU使用率表示 CPU 时间在各个状态（user/system/iowait/idle等）上的占比。
- 高使用率不一定表示异常，关键看**user 和 system 占比是否合理，是否长时间满载**。

------

### 🧭 排查思路总览：

| 排查点                  | 工具                                | 目的                         |
| ----------------------- | ----------------------------------- | ---------------------------- |
| user/system/iowait 占比 | `top`, `mpstat`, `sar`              | 判断是用户进程还是系统调用多 |
| 找到高CPU进程           | `top`, `ps`, `htop`                 | 定位消耗CPU最多的进程        |
| 单进程线程分析          | `top -H`, `perf top`                | 查看是哪个线程在占用CPU      |
| GC or 死循环            | `jstat`, `jstack`, `strace`, `perf` | 分析是否Java GC或死循环造成  |
| 编译/压缩/加密          | `lsof`, `iotop`                     | 查看是否为正常高CPU场景      |



------

### 🧪 详细排查步骤

#### 1. 查看 CPU 各状态占比

```
top
# 看 %us、%sy、%id、%wa、%st
```

或使用：

```
mpstat -P ALL 1
```

关键状态解释：

| 状态  | 含义     | 异常现象             |
| ----- | -------- | -------------------- |
| `%us` | 用户空间 | 用户程序异常、死循环 |
| `%sy` | 内核空间 | 系统调用频繁         |
| `%wa` | IO等待   | 磁盘/网络阻塞        |
| `%st` | 虚拟抢占 | 云服务器被抢占CPU    |



#### 2. 定位高 CPU 进程

```
ps -eo pid,ppid,cmd,%cpu --sort=-%cpu | head
```

#### 3. 分析线程级别CPU

```
top -H -p <pid>
# 或者
ps -L -p <pid> -o pid,tid,%cpu,cmd
```

再结合：

```
printf "%x\n" <tid>  # 转成十六进制 ThreadId
jstack <pid> | grep -A30 <hex_tid>  # 若是Java进程
```

#### 4. 分析GC、死循环

- Java进程：

```
jstat -gcutil <pid> 1000 5  # 观察 GC 是否频繁
jstack <pid>                # 检查是否线程死循环或阻塞
```

- Python、C进程：

```
strace -p <pid>
perf top -p <pid>
```

------

## 🔍 总结对比表

| 项目     | CPU负载高                                                  | CPU利用率高                                      |
| -------- | ---------------------------------------------------------- | ------------------------------------------------ |
| 概念     | 排队等待执行的任务数多                                     | CPU工作状态占用高                                |
| 判断依据 | `load average` > 核数                                      | `%us + %sy` 高于合理范围                         |
| 可能原因 | 并发高、上下文切换多、IO阻塞                               | 死循环、GC频繁、系统调用异常                     |
| 工具推荐 | `uptime`, `vmstat`, `pidstat -w`, `mpstat`, `ps -eo state` | `top`, `mpstat`, `ps -eo %cpu`, `perf`, `strace` |


## 常见语言的调试工具：
* Java: jstat、jstack
* Python: py-spy
* go: pprof