# CPU负载高排查

- [CPU负载高排查](#cpu负载高排查)
  - [🔍 一、CPU负载的定义与理解](#-一cpu负载的定义与理解)
  - [🧭 二、排查总览流程](#-二排查总览流程)
  - [🔎 三、排查步骤详解](#-三排查步骤详解)
    - [1. 确认负载是否异常](#1-确认负载是否异常)
    - [2. 分析负载构成（CPU / IO / 内存）](#2-分析负载构成cpu--io--内存)
      - [2.1 用户态/系统态的比例（top）](#21-用户态系统态的比例top)
    - [3. 定位高消耗的进程](#3-定位高消耗的进程)
    - [4. 查看具体线程（如 Java）](#4-查看具体线程如-java)
    - [5. 分析系统资源调用情况](#5-分析系统资源调用情况)
    - [6. 排查是否为内存或交换区引起的间接负载](#6-排查是否为内存或交换区引起的间接负载)
    - [7. 排查是否为调度问题（特别是虚拟化环境）](#7-排查是否为调度问题特别是虚拟化环境)
  - [🔬 四、典型场景举例](#-四典型场景举例)
    - [✅ Java GC 导致 CPU 高](#-java-gc-导致-cpu-高)
    - [✅ 死循环代码](#-死循环代码)
    - [✅ 网络风暴/频繁系统调用](#-网络风暴频繁系统调用)
    - [✅ 容器或虚拟化限制](#-容器或虚拟化限制)
    - [✅ 五、优化建议](#-五优化建议)
    - [🎯 六、总结](#-六总结)

## 🔍 一、CPU负载的定义与理解
* CPU负载（Load Average）：是系统运行队列中的平均进程数量，常通过 uptime 或 top 查看。

  * 例如：load average: 4.35, 3.86, 3.64

  * 如果是4核CPU，负载超过4（比如 8.0）说明 CPU 资源可能不足。

## 🧭 二、排查总览流程
```
确认现象 → 分析load类型 → 定位消耗资源的进程 → 查看系统行为 → 判断异常源头
```
## 🔎 三、排查步骤详解

### 1. 确认负载是否异常
查看当前负载：
```
uptime
top -n 1
```
* 判断是否超过CPU核心数（比如单核负载为 1，4核负载 > 4 就偏高）。

* 区分是瞬时高负载还是持续性高负载。

### 2. 分析负载构成（CPU / IO / 内存）
使用 top、vmstat、iostat、pidstat 等命令：

#### 2.1 用户态/系统态的比例（top）
```
top
```
* %us：用户态 CPU（例如高频业务逻辑、计算任务）

* %sy：内核态 CPU（系统调用、网络/IO等）

* %id：空闲

* %wa：IO等待

* %st：steal（虚拟机中被其他实例抢占）

判断依据：

| 情况 | 说明                       |
| --- |--------------------------|
| %us 高 | 应用程序本身计算密集或死循环           |
| %sy 高 | 系统调用频繁，可能是网络、磁盘或系统函数调用过多 |
| %wa 高 | IO瓶颈（磁盘/网络）导致CPU等待       |

### 3. 定位高消耗的进程
```
top -o %CPU
ps -eo pid,ppid,cmd,%cpu,%mem --sort=-%cpu | head
```
* 找出哪个进程最耗CPU。

* 注意查看是否有僵尸进程（状态为 Z）。

* 如为Java应用，可进一步用 jstack 分析线程。

### 4. 查看具体线程（如 Java）
```
top -H -p <PID>
```
查找占用CPU的线程TID。

转换为16进制 TID，用 jstack 定位栈信息（如是 Java）：
```
printf "%x\n" 12345
jstack <pid> | grep -A 30 <TID in hex>
```

### 5. 分析系统资源调用情况
```
strace -p <pid> -tt
perf top
```
* strace：系统调用频率高说明可能是密集的IO或网络操作。

* perf top：查看内核函数耗时，定位性能热点。

### 6. 排查是否为内存或交换区引起的间接负载
如果内存不足，系统频繁 swap，会造成CPU等待。
```
free -m
vmstat 1 5
```
* 如果 si（swap in）/so（swap out）高，说明内存不足。

### 7. 排查是否为调度问题（特别是虚拟化环境）
* %st（steal）高说明虚拟机CPU资源被“偷走”。

* 可能需要和云厂商沟通或迁移实例。

## 🔬 四、典型场景举例
### ✅ Java GC 导致 CPU 高
* 查看进程是否为 Java 应用

* 使用 jstat 查看 GC 情况
```
jstat -gcutil <pid> 1s
```
* Full GC频繁可能是老年代满了，造成 Stop-the-World，CPU骤升。

### ✅ 死循环代码
* 单线程CPU占用100%，用 strace 或 gdb/perf 分析函数调用。

### ✅ 网络风暴/频繁系统调用
* strace 显示频繁 recvfrom, sendto, poll, epoll_wait 等。

### ✅ 容器或虚拟化限制
容器 CPU 限制（cpu quota）触发 throttle

使用：
```
docker stats
kubectl top pod
```

### ✅ 五、优化建议
* 应用层面优化：修复死循环、GC调整、分片计算

* 系统层面优化：加核、限制进程资源、调整调度策略

* 运维层面优化：设置CPU告警，自动采样留证，调度更合理

### 🎯 六、总结
高 CPU 负载并不一定是“CPU忙”，也可能是内存、IO、线程调度等问题间接导致的。关键是结合实际场景，逐步缩小排查范围，定位根因。

> 🔧 建议形成 SOP（标准操作流程）文档，结合 top + pidstat + strace + perf + jstack 工具链，提升效率。